/*
 * This build file was auto generated by running the Gradle 'init' task
 * by 'lk' at '18/02/16 10:15' with Gradle 2.11
 *
 * This generated file contains a commented-out sample Java project to get you started.
 * For more details take a look at the Java Quickstart chapter in the Gradle
 * user guide available at https://docs.gradle.org/2.11/userguide/tutorial_java_projects.html
 *
 * @author Laurent Krishnathas
 */

import org.apache.commons.io.output.TeeOutputStream

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSession;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import java.security.cert.X509Certificate;


buildscript {
    repositories {
        jcenter()
        mavenLocal()
        mavenCentral()
    }
    
    dependencies {
        classpath "commons-io:commons-io:2.4"
    }
}

apply plugin: 'groovy'

repositories {
    jcenter()
}

dependencies {
    compile 'org.slf4j:slf4j-api:1.7.14'
    testCompile 'junit:junit:4.12'
}

task traceroute(){
    description="tracing some hostnames ..."
    ext.destinationDir="$buildDir/$name" as File

    doLast{ 
        logger.lifecycle "Please wait..., this may take several hours ..."
        def hostList=[
            "s3-us-west-2.amazonaws.com",
            "s3.amazonaws.com",
            "s3-external-1.amazonaws.com",
            /*
            "s3-us-west-2.amazonaws.com",
            "s3-us-west-1.amazonaws.com", 
            "s3-eu-west-1.amazonaws.com",  
            "s3.eu-central-1.amazonaws.com",
            "s3-eu-central-1.amazonaws.com"
            */
        ]

        ant.mkdir(dir:destinationDir)

        def hostname="hostname".execute().text.trim()

        File file="$destinationDir/traceroute_${hostname}.txt" as File

        def sep="\n---------------------------------------------------"        
        file.withWriter{ writer->

            writer.println("hostname is $hostname")

            hostList.each{ host->
                def byteOutput=new ByteArrayOutputStream()
                //def teeOutput=new TeeOutputStream(, System.out)

                exec{
                    if(System.properties.isdebug=="true"){
                        executable "ping"
                        args "-c", 1, host
                    }else{
                        executable "traceroute"
                        args host               
                    }
                    
                    standardOutput  byteOutput
                    errorOutput  byteOutput
                    ignoreExitValue true

                    def msg="$sep\n$executable ${args.join(" ")} ..."
                    logger.lifecycle(msg)
                    writer.println(msg)
                } 

                def text=byteOutput.toString()
                writer.println(text)
            }
        }

        logger.lifecycle "Done, please send the $file to lk@dotmatics.com, thank you."
    }
}

task hello{
    description="hello test"

    doLast{
        println "hello $it, $it.description"
    }
}


task fillDisk(){
    description="will fill the hard disk to errase all deleted files"
    ext.destinationDir="$buildDir/$name" as File

    doLast{
        logger.lifecycle "filling ..."
        def nbLines=1000
        def nbGig=250
        def nbFilesPerGig=1000
        def line="absbsgsdfgsgrshstgdfyujruyretdgsfhgryterytjfghfdsgeyrjfgdhdsgjtfgdhsgatyeujfghgeyeujgffhgey"

        if(false){
            logger.lifecycle "using debug ..."
            nbLines=10
            nbGig=2
            nbFilesPerGig=50
        }
        
        ant.mkdir(dir:destinationDir)

        def text=new StringBuilder()

        nbLines.times{
            text<<line
        }

        nbGig.times{g->
            def dir="$destinationDir/$g" as File
            ant.mkdir(dir:dir)
            nbFilesPerGig.times{n->
                if(n/100==0){
                   print "."
                }
                def time=new Date().time
                def file="$dir/${n}_${time}.txt" as File
                file.text=text
            }
            println "${g}G done."
        }
    }
}

task useUntrustedSsl {
    description= ''
    doLast{
        //http://www.rgagnon.com/javadetails/java-fix-certificate-problem-in-HTTPS.html
        TrustManager[] trustAllCerts = [
            new X509TrustManager() {
               public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                 return null;
               }
     
               public void checkClientTrusted(X509Certificate[] certs, String authType) {  }
     
               public void checkServerTrusted(X509Certificate[] certs, String authType) {  }
     
            }
         ]
     
         SSLContext sc = SSLContext.getInstance("SSL");
         sc.init(null, trustAllCerts, new java.security.SecureRandom());
         println "setting default ssl socket factory..."
         HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());

        javax.net.ssl.HttpsURLConnection.setDefaultHostnameVerifier(
            new javax.net.ssl.HostnameVerifier(){

            public boolean verify(String hostname,
                    javax.net.ssl.SSLSession sslSession) {
                return true;
            }
        });
    }
}

task checkHTTPS{
    description= ''
    dependsOn= ['useUntrustedSsl']
    ext{
        destinationDir= "$buildDir/checkHTTPS" as File
    }

    doLast{
        ant.mkdir(dir:destinationDir)
        def list=[
            'http://support.dotmatics.com/hudson/',
            'https://support.dotmatics.com/hudson/',
            'https://support.dotmatics.com'
        ]

        def index=-1
        list.each{url-> 
            index++

            logger.lifecycle "getting $url ..."
            def text= new URL(url).text
            File file="$destinationDir/${index}.html" as File
            File file2="$destinationDir/${index}.txt" as File
            file.text=text
            file2.text=text
            logger.lifecycle 'done'
        }

    }
}

task createLicenceSvnserve(type: Exec){
    description= ''
	executable = "sc"
	args "create", "svnserver_licences", 'binpath= "\"C:\\Program Files (x86)\\CollabNet\\Subversion Server\\svnserve.exe\" --service -r e:\\svnRepositories\\licences"', 'displayname= "Subversion server licences"', 'depend= Tcpip', 'start= auto'	
}


task removeLicenceSvnserve(type: Exec){
    description= ''
	
	executable= "sc"
	args "delete svnserver_licences"
}

task generateKeystore(type: Exec){ task->
    description= 'Generate a keystore for selfsigning jar, no need to sign'
    
    ext{
        destinationDir= "$buildDir/${task.name}" as File
        destinationFile= "$destinationDir/keystore.jks" as File
            
        inputs.files "$rootDir/build.gradle", "$rootDir/gradle.properties"
        outputs.files ext.destinationFile   
    }
        
    workingDir ext.destinationDir

    executable 'keytool'    
    args '-genkey'
    args '-noprompt' 
    args '-alias', signJarAlias
    args '-dname', "CN=dotmatics.com, OU=ID, O=DOTMATICS, L=Build, S=Build, C=GB"
    args '-keystore', destinationFile
    args '-storepass', signJarStorepass
    args '-keypass', signJarStorepass
    args '-validity', '365'
    
    doFirst{
        ant.delete(dir:ext.destinationDir)
        ant.mkdir(dir:ext.destinationDir)
    }
    
    doLast{
        assert ext.destinationFile.exists(): "$destinationFile must be exists"  
    }
} 


task downloadGit(type: devops.DownloadTask){task->
    description="download git 32 to destination folder"
    destinationDir="$buildDir/$task.name" as File
    url="https://github.com/git-for-windows/git/releases/download/v2.11.0.windows.1/PortableGit-2.11.0-32-bit.7z.exe"
    
    // 64 url="https://github.com/git-for-windows/git/releases/download/v2.11.0.windows.1/PortableGit-2.11.0-64-bit.7z.exe"
}

task gitPull(){task->
    dependsOn 'makeGitRepo'
    description="??"

    doLast{

        exec{
            executable="cmd"
            workingDir rootDir
            args "/C", makeGitRepo.gitExe, 'pull'
            logger.lifecycle "/> $executable ${args.join(' ')}"
        }
    }
}

task makeGitRepo(){task->
    dependsOn 'installGit'
    description="??"

    ext{
        destinationDir="$buildDir/$task.name" as File
        gitDir="$rootDir/.git" as File
        gitExe="$rootDir/bin/bin/git.exe" as File
    }

    doLast{
        delete(destinationDir)
        mkdir(destinationDir)
        if(!gitDir.exists()){
            exec{
                executable="cmd"
                workingDir destinationDir
                args "/C", gitExe, 'clone', "https://github.com/LaurentKrishnathas/utils.git"
                logger.lifecycle "/> $executable ${args.join(' ')}"
            }

            def checkoutGitDir="$destinationDir/utils/.git" as File
            assert checkoutGitDir.exists(): "$checkoutGitDir must exits"
            ant.copy(todir: gitDir){
                fileset(dir: checkoutGitDir)
            }

            assert gitDir.exists(): "$gitDir must exits"
            assert gitDir.listFiles().size()>0: "$gitDir size must be not zero"
        }
    }
}

task installGit(){task->
    dependsOn 'extractGit'
    description="???"

    ext{
        binDir="$rootDir/bin" as File    
    }

    outputs.dir binDir

    doLast{
        mkdir(binDir)
        ant.copy(todir: binDir){
            fileset(dir: "$extractGit.destinationDir/PortableGit"){
                include(name: "**/*")
            }
        }
    }
}

task extractGit(){task->
    dependsOn 'downloadGit'
    description="install git"

    ext{
        destinationDir="$buildDir/$task.name" as File
        exeFile="$destinationDir/${task.name}.exe" as File
    }

    outputs.dir destinationDir

    doLast{
        def file=downloadGit.destinationDir.listFiles().find{it.name.endsWith('.exe')}
        assert file.exists():'exe file is missing'
        ant.copy(file: file, tofile: exeFile)
        mkdir(destinationDir)

        exec{
            workingDir destinationDir

            executable 'cmd'
            args "/C", exeFile.name, '-y'
            logger.lifecycle "/> $executable ${args.join(' ')}"
        }

    }
}

task gitGradlew{task->
    dependsOn "makeGitRepo"
    description= "generate  ${task.name}.bat"

    ext{
        destinationFile="$project.rootDir/${task.name}.bat" as File
    }
    
    outputs.file destinationFile

    doLast{
        project.delete(destinationFile)
        destinationFile.text="""
            @echo off
            bin\\bin\\git pull
            gradlew.bat %1 %2 %3 %4 %5 -Dlog=debug      
        """.stripIndent()               
    }
}



